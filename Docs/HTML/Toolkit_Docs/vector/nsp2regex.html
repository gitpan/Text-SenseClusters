<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>nsp2regex.pl</title>
<link rev="made" href="mailto:jluttine@marimba.d.umn.edu" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#usage">USAGE</a></li>
	<li><a href="#input">INPUT</a></li>
	<ul>

		<li><a href="#required_arguments_">Required Arguments:</a></li>
		<ul>

			<li><a href="#source">SOURCE</a></li>
		</ul>

		<li><a href="#optional_arguments">Optional Arguments</a></li>
		<ul>

			<li><a href="#token_file">-token FILE</a></li>
			<li><a href="#version">-version</a></li>
			<li><a href="#help">-help</a></li>
		</ul>

	</ul>

	<li><a href="#output">OUTPUT</a></li>
	<li><a href="#explanation_of_the_created_regular_expressions">Explanation of the created Regular Expressions</a></li>
	<ul>

		<li><a href="#default_regular_expression__without_skipping_intermediate_tokens__">Default Regular Expression (without Skipping Intermediate Tokens):</a></li>
		<li><a href="#what_this_regular_expression_will_match_">What This Regular Expression will Match:</a></li>
		<li><a href="#explanation_of_this_regular_expression_">Explanation of this Regular Expression:</a></li>
		<li><a href="#regular_expression_with_skipping_of_intermediate_tokens_">Regular Expression with Skipping of Intermediate Tokens:</a></li>
		<li><a href="#what_this_regular_expression_will_match_">What This Regular Expression will Match:</a></li>
		<li><a href="#explanation_of_this_regular_expression_">Explanation of this Regular Expression:</a></li>
		<li><a href="#a_fine_point_about_nsp2regex_pl_">A Fine Point about nsp2regex.pl:</a></li>
	</ul>

	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>nsp2regex.pl</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>Takes n-word sequences and represents them as regular 
expressions. These can then be used to identify lexical 
features in a given data, and convert a lexical element 
files from text into feature vectors.</p>
<p>
</p>
<hr />
<h1><a name="usage">USAGE</a></h1>
<p>nsp2regex.pl [OPTIONS] SOURCE [[, SOURCE] ...]</p>
<p>
</p>
<hr />
<h1><a name="input">INPUT</a></h1>
<p>
</p>
<h2><a name="required_arguments_">Required Arguments:</a></h2>
<p>
</p>
<h3><a name="source">SOURCE</a></h3>
<p>The SOURCE is a file containing the list of features. 
The features are required to be in specific format:</p>
<p>the_feature_token&lt;&gt;</p>
<p>eg:
Unigram feature: temperature&lt;&gt;
Bigram feature: daily&lt;&gt;temperature&lt;&gt;
</p>
<pre>

count.pl or statistic.pl (both part of the Ngram Statistics Package) 
created output can be directly used as the SOURCE file.</pre>
<p>
</p>
<h2><a name="optional_arguments">Optional Arguments</a></h2>
<p>
</p>
<h3><a name="token_file">--token FILE</a></h3>
<p>Uses tokens contained in FILE to create the separator
between tokens, when window size of SOURCE n-gram is
greater than the 'n' of the n-gram. Window sizes for
n-grams in SOURCE can be defined using the --extended
option in count.pl.</p>
<p>
</p>
<h3><a name="version">--version</a></h3>
<p>Prints the version number.</p>
<p>
</p>
<h3><a name="help">--help</a></h3>
<p>Prints this help message.</p>
<p>
</p>
<hr />
<h1><a name="output">OUTPUT</a></h1>
<p>Outputs the generated regular expressions to stdout.</p>
<p>
</p>
<hr />
<h1><a name="explanation_of_the_created_regular_expressions">Explanation of the created Regular Expressions</a></h1>
<p>
</p>
<h2><a name="default_regular_expression__without_skipping_intermediate_tokens__">Default Regular Expression (without Skipping Intermediate Tokens):</a></h2>
<p>By default nsp2regex.pl creates regex's that match space
separated tokens. The regular expressions that nsp2regex.pl creates 
are based on the assumption that the text on
which these regex's are going to be used has tokens separated by a
single space. Further the regular expressions thus created ignore XML
tags and non-tokens, as described in the examples above.</p>
<p>For example, the following line in the input to nsp2regex.pl:
a&lt;&gt;bigram&lt;&gt;</p>
<p>is converted to the following regex: 
/\s(&lt;[^&gt;]*&gt;)*a(&lt;[^&gt;]*&gt;)*\s(&lt;[^&gt;]*&gt;\s)*(&lt;[^&gt;]*&gt;)*bigram(&lt;[^&gt;]*&gt;)*\s/ @name = a&lt;&gt;bigram</p>
<p>In this output, everything from the first / to the last / constitutes
the regular expression. The portion ``@name = a&lt;&gt;bigram'' is used by
xml2arff.pl (from SenseTools package) for giving a name to the attribute 
corresponding to this regular expression.</p>
<p>
</p>
<h2><a name="what_this_regular_expression_will_match_">What This Regular Expression will Match:</a></h2>
<p>This regular expression defines a feature that will match the tokens
``a'' and ``bigram'' under the following conditions:</p>
<p>i&gt;   Tokens ``a'' and ``bigram'' have exactly one space to their left and
     right. For example, this regex will match the sentence `` this is a
     bigram ''. This regex will not match the sentence `` i wanna bigram ''
     nor the sentence `` i have a bigrams ''. It will not even match `` I
     have a    bigram ''. This is because nsp2regex.pl creates regular
     expressions that assume that there is exactly ONE space character
     between tokens!</p>
<p>ii&gt;  Tokens ``a'' and ``bigram'' are bounded by one or more xml tags or
     non-tokens, that is a sequence of characters that start with '&lt;'
     and end with '&gt;'. eg: this regex will match the sentence : `` this
     is a &lt;head&gt;bigram&lt;/head&gt; ''. This regex will also match `` this is
     a &lt;head&gt;bigram&lt;senseid=20/&gt;&lt;/head&gt; ''.</p>
<p>iii&gt; tokens ``a'' and ``bigram'' are separated by one or more space
     separated xml tags.  eg: this regex will match the sentence `` this
     is a &lt;,&gt; bigram ''. It will also match `` this is a &lt;,&gt; bigram &lt;!&gt;
     '' and `` this is a &lt;,&gt; &lt;head&gt;bigram&lt;/head&gt; ''.</p>
<p>iv&gt;  combinations of the above cases.</p>
<p>
</p>
<h2><a name="explanation_of_this_regular_expression_">Explanation of this Regular Expression:</a></h2>
<p>Following is an explanation of the various parts of the regular
expression:</p>
<p>/\s(&lt;[^&gt;]*&gt;)*a(&lt;[^&gt;]*&gt;)*\s(&lt;[^&gt;]*&gt;\s)*(&lt;[^&gt;]*&gt;)*bigram(&lt;[^&gt;]*&gt;)*\s/ @name = a&lt;&gt;bigram</p>
<p>a&gt; All the portion between the first '/' and the last '/' is the regular
   expression.</p>
<p>b&gt; The regular expression starts with requiring a single space
   character, \s. This is consistent with the assumption that every
   token has exactly one space to its left and one to its right.</p>
<p>c&gt; The next chunk is (&lt;[^&gt;]*&gt;)*a(&lt;[^&gt;]*&gt;)*
   Note that the portion (&lt;[^&gt;]*&gt;) represents exactly our definition
   of an XML tag, namely that it should start with a '&lt;', have 0 or
   more characters, except the '&gt;' character, and then end with the
   '&gt;' character. The '*' outside the bracket denotes that we are
   willing to match 0 or more such tags. After that, we wish to match
   a single occurrence of the first token, 'a', again followed by 0 or
   more tags. Note that the tags are ``stuck'' to the token 'a', in that
   there is no space between the tag and the token 'a'. Of course if
   in the text there is a space between an XML tag and 'a', then the
   space would match the space in &lt;b&gt; above.</p>
<p>d&gt; Having matched token 'a' with 0 or more tags ``stuck'' to its right
   and left, we now wish to match exactly a single space character
   through the \s. Again this corresponds to our assumption that
   tokens in the text are separated by exactly one space character!</p>
<p>e&gt; The next chunk (&lt;[^&gt;]*&gt;\s)* is again our familiar XML tag. This
   time we wish to ``skip'' over 0 or more occurrences of any XML tag
   that lie between the first and the second token, ie between 'a' and
   'bigram'. Since these are not ``stuck'' to the next token 'bigram',
   they are space separated from each other and from 'bigram'. Hence,
   for every token we match, we also match a space character!</p>
<p>f&gt; The next chunk is (&lt;[^&gt;]*&gt;)*bigram(&lt;[^&gt;]*&gt;)* which is exactly like
   the chunk for 'a' in point &lt;c&gt; above.</p>
<p>g&gt; Finally we wish to match a single space character \s.</p>
<p>h&gt; The portion after the last '/' @name = a&lt;&gt;bigram creates a ``name''
   for this feature. This name is used by xml2arff (from SenseTools 
   package) while creating the vector output of the input XML file. 
   While this name is not necessary, it makes the vector output more 
   human-readable.</p>
<p>
</p>
<h2><a name="regular_expression_with_skipping_of_intermediate_tokens_">Regular Expression with Skipping of Intermediate Tokens:</a></h2>
<p>nsp2regex.pl can create regular expressions that ignore
one or more tokens that occur between the tokens to be
matched. This can be switched ``ON'' by having the
directive ``@count.WindowSize=...'' in the input file to
nsp2regex.pl. We need to provide nsp2regex.pl with the same token file
we provide preprocess.pl... say following is the token file:</p>
<p>/&lt;head&gt;\w+&lt;\/head&gt;/
/\w+/</p>
<p>Let the input file to the nsp2regex.pl program be the following:</p>
<p>@count.WindowSize=3
a&lt;&gt;bigram&lt;&gt;</p>
<p>then, the output regular expression from nsp2regex.pl is:</p>
<p>/\s(&lt;[^&gt;]*&gt;)*a(&lt;[^&gt;]*&gt;)*\s(&lt;[^&gt;]*&gt;\s)*((&lt;[^&gt;]*&gt;)*((&lt;head&gt;\w+&lt;\/head&gt;)|(\w+))(&lt;[^&gt;]*&gt;)*\s(&lt;[^&gt;]*&gt;\s)*){0,1}(&lt;[^&gt;]*&gt;)*bigram(&lt;[^&gt;]*&gt;)*\s/ @name = a&lt;&gt;bigram&lt;&gt;1</p>
<p>
</p>
<h2><a name="what_this_regular_expression_will_match_">What This Regular Expression will Match:</a></h2>
<p>This regular expression will match the tokens ``a'' and ``bigram''
separated by 0 or 1 occurrences of the white space separated token
((&lt;head&gt;\w+&lt;\/head&gt;)|(\w+)). This is the token definitions obtained
from the token.txt file above!</p>
<p>For example, this regular expression will match the following
sentences: 
`` this is a funny bigram ''
`` this is a bigram ''
`` this is a &lt;head&gt;nice&lt;/head&gt; bigram ''
`` this is a &lt;,&gt; bigram ''
`` this is a &lt;,&gt; &lt;head&gt;nice&lt;/head&gt; bigram ''</p>
<p>This regular expression will not match:
`` this is a really big bigram '',
`` i wanna write bigram ''.
`` this is a , bigram '',</p>
<p>
</p>
<h2><a name="explanation_of_this_regular_expression_">Explanation of this Regular Expression:</a></h2>
<p>Following is a description of various parts of the regular expression:</p>
<p>/\s(&lt;[^&gt;]*&gt;)*a(&lt;[^&gt;]*&gt;)*\s(&lt;[^&gt;]*&gt;\s)*((&lt;[^&gt;]*&gt;)*((&lt;head&gt;\w+&lt;\/head&gt;)|(\w+))(&lt;[^&gt;]*&gt;)*\s(&lt;[^&gt;]*&gt;\s)*){0,1}(&lt;[^&gt;]*&gt;)*bigram(&lt;[^&gt;]*&gt;)*\s/ @name = a&lt;&gt;bigram&lt;&gt;1</p>
<p>On careful observation one will notice that the above regular
expression differs from the previous regular expression (section 6.1.2)
in only one portion.</p>
<p>Specifically the portion \s(&lt;[^&gt;]*&gt;)*a(&lt;[^&gt;]*&gt;)*\s(&lt;[^&gt;]*&gt;\s)* is the
same as above... this matches a space, followed by 'a'
with XML tags or non-token characters (within &lt;&gt; brackets) stuck to
its left and right, followed by a single space, followed by 0 or more
XML tags and non-token characters, with a space after every such tag.</p>
<p>Further note that the portion (&lt;[^&gt;]*&gt;)*bigram(&lt;[^&gt;]*&gt;)*\s is again
the same as before... they match 'bigram' with XML tags and non-token
character tags stuck to its left and right, followed by a single
space.</p>
<p>Thus the only ``new'' portion in this regex is 
((&lt;[^&gt;]*&gt;)*((&lt;head&gt;\w+&lt;\/head&gt;)|(\w+))(&lt;[^&gt;]*&gt;)*\s(&lt;[^&gt;]*&gt;\s)*){0,1}</p>
<p>We call this the ``separator'' portion of the regex; this is the portion
that allows for the ``ignoring'' of up to one token between the tokens
'a' and 'bigram'. This token can be either a &lt;head&gt;\w+&lt;/head&gt; or a
\w+.</p>
<p>a&gt; Observe that the entire section is within a pair of round brackets,
   followed by a {0,1}. This says that this portion is allowed to
   occur 0 or 1 times. This is consistent with the window size of
   3... besides 'a' and 'bigram', we allow at most one other token to
   come into the window. If our window size were to be 10 say, this
   would be {0,8}.</p>
<p>b&gt; The first part inside this bracketed portion is 
   (&lt;[^&gt;]*&gt;)*((&lt;head&gt;\w+&lt;\/head&gt;)|(\w+))(&lt;[^&gt;]*&gt;)*. This says that we
   are willing to match either a &lt;head&gt;\w+&lt;/head&gt; or a \w+. Further
   whatever we match can be preceeded or followed by an XML tag or a
   non-token character ensconced with the angular brackets &lt;&gt;.</p>
<p>c&gt; Having matched either of the two options, we wish to match a single
   space, \s, followed by one or more XML tags or non-tokens, in
   keeping with our desire to skip these tags!</p>
<p>e&gt; And, as mentioned in &lt;a&gt; above, we would like to do this matching
   at most once, that is there will be at most one such token between
   'a' and 'bigram'.</p>
<p>f&gt; The name of the feature has also changed to @name = a&lt;&gt;bigram&lt;&gt;1
   implying that we are allowing at most one token to come in between
   our two main tokens!</p>
<p>
</p>
<h2><a name="a_fine_point_about_nsp2regex_pl_">A Fine Point about nsp2regex.pl:</a></h2>
<p>Fine Point 1: Certain characters, like '.', '*', '?' etc have special
meaning when used within a regular expression. If these characters
occur in the tokens that the regular expression is being built from,
they are ``escaped'' (by prepending them with a slash '\'). Following is
a list of characters that are so escaped: '\', '/', '|', '(', ')',
'[', ']', '{', '}', '^', '$', '*', '+', '?' and '.'</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<pre>
 Satanjeev Banerjee, Carnegie Mellon University, Pittsburgh.
 Ted Pedersen, University of Minnesota, Duluth.</pre>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright (c) 2001-2005,</p>
<pre>
 Satanjeev Banerjee, Carnegie Mellon University, Pittsburgh.
 satanjeev@cmu.edu</pre>
<pre>
 Ted Pedersen, University of Minnesota, Duluth.
 tpederse@umn.edu</pre>
<p>This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with
this program; if not, write to</p>
<p>The Free Software Foundation, Inc.,
59 Temple Place - Suite 330,
Boston, MA  02111-1307, USA.</p>

</body>

</html>
